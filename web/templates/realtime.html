{% extends "base.html" %}

{% block title %}Real-Time Analysis - Network IDS{% endblock %}

{% block content %}
<div class="realtime-page">
    <header class="page-header">
        <h1>Real-Time Traffic Analysis</h1>
        <div class="header-controls">
            <select id="interface-select" class="select-input">
                <option value="">Select Interface</option>
                {% for iface in interfaces %}
                <option value="{{ iface.name }}">{{ iface.name }} ({{ iface.ips|join(', ') }})</option>
                {% endfor %}
            </select>
            <button type="button" id="refresh-interfaces" class="btn btn-secondary" title="Refresh interfaces">â†»</button>
            <input type="number" id="threshold-input" class="number-input" value="0.5" min="0" max="1" step="0.1" title="Detection Threshold">
            <button id="start-btn" class="btn btn-primary">Start Capture</button>
            <button id="stop-btn" class="btn btn-danger" disabled>Stop</button>
        </div>
    </header>

    <div class="status-bar" id="status-bar">
        <div class="status-indicator offline" id="status-indicator">
            <span class="status-dot"></span>
            <span class="status-text">Offline</span>
        </div>
        <div class="status-stats">
            <div class="stat">
                <span class="stat-value" id="stat-packets">0</span>
                <span class="stat-label">Packets</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="stat-flows">0</span>
                <span class="stat-label">Flows</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="stat-attacks">0</span>
                <span class="stat-label">Attacks</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="stat-pps">0</span>
                <span class="stat-label">Packets/s</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="stat-rate">0%</span>
                <span class="stat-label">Attack Rate</span>
            </div>
        </div>
    </div>

    <div class="metrics-row">
        <div class="metric-card chart-card">
            <h3>Traffic Rate (packets/s)</h3>
            <div class="chart-container">
                <canvas id="traffic-chart"></canvas>
            </div>
        </div>
        <div class="metric-card value-card">
            <h3>Active Flows</h3>
            <div class="metric-value" id="active-flows">0</div>
        </div>
        <div class="metric-card chart-card">
            <h3>Attack Rate (%)</h3>
            <div class="chart-container">
                <canvas id="attack-chart"></canvas>
            </div>
        </div>
    </div>

    <section class="flows-section">
        <div class="section-header">
            <h2>Recent Flows</h2>
            <label class="checkbox-label">
                <input type="checkbox" id="attacks-only"> Show attacks only
            </label>
        </div>
        <div class="flows-table-wrapper">
            <table class="data-table" id="flows-table">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Status</th>
                        <th>Source</th>
                        <th>Destination</th>
                        <th>Protocol</th>
                        <th>Confidence</th>
                        <th>Packets</th>
                    </tr>
                </thead>
                <tbody id="flows-body">
                    <tr class="empty-row">
                        <td colspan="7">No flows captured yet. Select an interface and start the capture.</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
const MAX_CHART_POINTS = 60;
const MAX_FLOWS = 50;

let trafficChart, attackChart;
let trafficData = [];
let attackData = [];
let flows = [];
let eventSource = null;
let isRunning = false;

// Initialize charts
function initCharts() {
    const chartOptions = {
        responsive: true,
        maintainAspectRatio: true,
        animation: false,
        scales: {
            x: { display: false },
            y: {
                beginAtZero: true,
                ticks: { maxTicksLimit: 5 }
            }
        },
        plugins: {
            legend: { display: false }
        },
        elements: {
            point: { radius: 0 },
            line: { borderWidth: 2 }
        }
    };

    const trafficCtx = document.getElementById('traffic-chart');
    if (trafficCtx) {
        trafficChart = new Chart(trafficCtx, {
            type: 'line',
            data: {
                labels: Array(MAX_CHART_POINTS).fill(''),
                datasets: [{
                    data: Array(MAX_CHART_POINTS).fill(0),
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    fill: true,
                    tension: 0.3
                }]
            },
            options: chartOptions
        });
    }

    const attackCtx = document.getElementById('attack-chart');
    if (attackCtx) {
        attackChart = new Chart(attackCtx, {
            type: 'line',
            data: {
                labels: Array(MAX_CHART_POINTS).fill(''),
                datasets: [{
                    data: Array(MAX_CHART_POINTS).fill(0),
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    fill: true,
                    tension: 0.3
                }]
            },
            options: chartOptions
        });
    }
}

// Update charts with new data
function updateCharts(stats) {
    if (trafficChart) {
        trafficData.push(stats.packets_per_sec || 0);
        if (trafficData.length > MAX_CHART_POINTS) {
            trafficData.shift();
        }
        trafficChart.data.datasets[0].data = [...trafficData];
        while (trafficChart.data.datasets[0].data.length < MAX_CHART_POINTS) {
            trafficChart.data.datasets[0].data.unshift(0);
        }
        trafficChart.update('none');
    }

    if (attackChart) {
        attackData.push(stats.attack_rate || 0);
        if (attackData.length > MAX_CHART_POINTS) {
            attackData.shift();
        }
        attackChart.data.datasets[0].data = [...attackData];
        while (attackChart.data.datasets[0].data.length < MAX_CHART_POINTS) {
            attackChart.data.datasets[0].data.unshift(0);
        }
        attackChart.update('none');
    }
}

// Update stats display
function updateStats(stats) {
    document.getElementById('stat-packets').textContent = (stats.packets || 0).toLocaleString();
    document.getElementById('stat-flows').textContent = (stats.flows || 0).toLocaleString();
    document.getElementById('stat-attacks').textContent = (stats.attacks || 0).toLocaleString();
    document.getElementById('stat-pps').textContent = (stats.packets_per_sec || 0).toFixed(1);
    document.getElementById('stat-rate').textContent = (stats.attack_rate || 0).toFixed(2) + '%';
    document.getElementById('active-flows').textContent = stats.active_flows || 0;

    updateCharts(stats);
}

// Add flow to table
function addFlow(flow) {
    flows.unshift(flow);
    if (flows.length > MAX_FLOWS) {
        flows.pop();
    }
    renderFlows();
}

// Render flows table
function renderFlows() {
    const tbody = document.getElementById('flows-body');
    const attacksOnly = document.getElementById('attacks-only').checked;

    let displayFlows = attacksOnly ? flows.filter(f => f.is_attack) : flows;

    if (displayFlows.length === 0) {
        tbody.innerHTML = '<tr class="empty-row"><td colspan="7">No flows to display</td></tr>';
        return;
    }

    tbody.innerHTML = displayFlows.slice(0, MAX_FLOWS).map(flow => {
        const time = flow.timestamp ? new Date(flow.timestamp).toLocaleTimeString() : '-';
        const status = flow.is_attack ?
            '<span class="badge badge-danger">ATTACK</span>' :
            '<span class="badge badge-success">BENIGN</span>';
        const proto = {6: 'TCP', 17: 'UDP', 1: 'ICMP'}[flow.protocol] || flow.protocol;

        return `<tr class="${flow.is_attack ? 'row-attack' : ''}">
            <td>${time}</td>
            <td>${status}</td>
            <td>${flow.src_ip}:${flow.src_port}</td>
            <td>${flow.dst_ip}:${flow.dst_port}</td>
            <td>${proto}</td>
            <td>${((flow.confidence || 0) * 100).toFixed(1)}%</td>
            <td>${flow.packets || 0}</td>
        </tr>`;
    }).join('');
}

// Refresh interfaces list
async function refreshInterfaces() {
    try {
        const response = await fetch('/realtime/interfaces');
        const interfaces = await response.json();

        const select = document.getElementById('interface-select');
        const currentValue = select.value;

        select.innerHTML = '<option value="">Select Interface</option>';
        interfaces.forEach(iface => {
            const option = document.createElement('option');
            option.value = iface.name;
            option.textContent = `${iface.name} (${iface.ips.join(', ')})`;
            select.appendChild(option);
        });

        // Restore selection if still available
        if (currentValue) {
            select.value = currentValue;
        }

        if (interfaces.length === 0) {
            alert('No network interfaces found. Make sure Npcap is installed and you are running as Administrator.');
        }
    } catch (e) {
        console.error('Error refreshing interfaces:', e);
        alert('Error loading interfaces: ' + e.message);
    }
}

// Start capture
async function startCapture() {
    const iface = document.getElementById('interface-select').value;
    const threshold = parseFloat(document.getElementById('threshold-input').value);

    if (!iface) {
        alert('Please select a network interface');
        return;
    }

    document.getElementById('start-btn').disabled = true;
    document.getElementById('start-btn').textContent = 'Starting...';

    try {
        const response = await fetch('/realtime/start', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({interface: iface, threshold: threshold})
        });

        const data = await response.json();

        if (data.status === 'success') {
            isRunning = true;
            flows = [];
            trafficData = [];
            attackData = [];
            updateUI();
            startEventStream();
        } else {
            alert('Error: ' + data.message + (data.trace ? '\n\n' + data.trace : ''));
        }
    } catch (e) {
        alert('Error starting capture: ' + e.message);
    }

    document.getElementById('start-btn').textContent = 'Start Capture';
    document.getElementById('start-btn').disabled = isRunning;
}

// Stop capture
async function stopCapture() {
    document.getElementById('stop-btn').disabled = true;
    document.getElementById('stop-btn').textContent = 'Stopping...';

    try {
        await fetch('/realtime/stop', {method: 'POST'});
    } catch (e) {
        console.error('Error stopping:', e);
    }

    isRunning = false;
    updateUI();

    if (eventSource) {
        eventSource.close();
        eventSource = null;
    }

    document.getElementById('stop-btn').textContent = 'Stop';
}

// Start SSE stream
function startEventStream() {
    if (eventSource) {
        eventSource.close();
    }

    eventSource = new EventSource('/realtime/events');

    eventSource.onmessage = function(e) {
        try {
            const event = JSON.parse(e.data);

            if (event.type === 'stats') {
                if (event.data.running === false && isRunning) {
                    // Server says not running but we think we are
                    isRunning = false;
                    updateUI();
                } else if (event.data.running) {
                    updateStats(event.data);
                }
            } else if (event.type === 'flow') {
                addFlow(event.data);
            } else if (event.type === 'attack') {
                // Flash attack indicator
                const attackStat = document.getElementById('stat-attacks');
                attackStat.classList.add('flash');
                setTimeout(() => attackStat.classList.remove('flash'), 500);
            }
        } catch (e) {
            console.error('Error parsing event:', e);
        }
    };

    eventSource.onerror = function(e) {
        console.log('SSE connection error, will retry...');
    };
}

// Update UI based on running state
function updateUI() {
    const indicator = document.getElementById('status-indicator');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const ifaceSelect = document.getElementById('interface-select');
    const refreshBtn = document.getElementById('refresh-interfaces');

    if (isRunning) {
        indicator.className = 'status-indicator online';
        indicator.querySelector('.status-text').textContent = 'Running';
        startBtn.disabled = true;
        stopBtn.disabled = false;
        ifaceSelect.disabled = true;
        refreshBtn.disabled = true;
    } else {
        indicator.className = 'status-indicator offline';
        indicator.querySelector('.status-text').textContent = 'Offline';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        ifaceSelect.disabled = false;
        refreshBtn.disabled = false;
    }
}

// Event listeners
document.getElementById('start-btn').addEventListener('click', startCapture);
document.getElementById('stop-btn').addEventListener('click', stopCapture);
document.getElementById('attacks-only').addEventListener('change', renderFlows);
document.getElementById('refresh-interfaces').addEventListener('click', refreshInterfaces);

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    initCharts();

    // If no interfaces, try to refresh
    const select = document.getElementById('interface-select');
    if (select.options.length <= 1) {
        refreshInterfaces();
    }
});
</script>
{% endblock %}